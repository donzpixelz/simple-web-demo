name: Deploy simple-web-demo to EC2

on:
  push:
    branches: [ main ]      # ← no paths filter; runs on any merge to main
  workflow_dispatch: {}      # ← lets you run it manually from Actions tab

permissions:
  id-token: write
  contents: read

env:
  AWS_REGION: us-east-2
  INSTANCE_NAME: simple-web-demo
  SERVICE_NAME: simple-web-demo
  REMOTE_USER: ubuntu
  REMOTE_DIR: /home/ubuntu/deploy/simple-web-demo

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials (OIDC)
        uses: aws-actions/configure-aws-credentials@v4
        with:
          role-to-assume: ${{ secrets.AWS_OIDC_ROLE_ARN }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Resolve EC2 public IP from Name tag
        id: ip
        run: |
          IP=$(aws ec2 describe-instances \
            --filters "Name=tag:Name,Values=${INSTANCE_NAME}" "Name=instance-state-name,Values=running" \
            --query "Reservations[0].Instances[0].PublicIpAddress" --output text)
          [ -n "$IP" ] && [ "$IP" != "None" ] || { echo "No running instance named ${INSTANCE_NAME}"; exit 1; }
          echo "ip=$IP" >> "$GITHUB_OUTPUT"

      - name: Setup SSH
        run: |
          install -m 700 -d ~/.ssh
          echo "${{ secrets.EC2_SSH_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa
          ssh-keyscan -H ${{ steps.ip.outputs.ip }} >> ~/.ssh/known_hosts

      - name: Push app/ and Dockerfile to instance
        run: |
          ssh ${{ env.REMOTE_USER }}@${{ steps.ip.outputs.ip }} "sudo mkdir -p '${REMOTE_DIR}' && sudo chown -R \$USER:\$USER '${REMOTE_DIR}'"
          rsync -avz --delete app/ ${{ env.REMOTE_USER }}@${{ steps.ip.outputs.ip }}:${{ env.REMOTE_DIR }}/app/ || true
          scp Dockerfile ${{ env.REMOTE_USER }}@${{ steps.ip.outputs.ip }}:${{ env.REMOTE_DIR }}/Dockerfile || true

      - name: Build & hot-swap container (always free port 80 first)
        run: |
          ssh ${{ env.REMOTE_USER }}@${{ steps.ip.outputs.ip }} <<'EOF'
            set -euo pipefail
            cd "${REMOTE_DIR}"

            # 1) Stop system webservers that may hold :80
            for svc in nginx apache2 httpd; do
              if systemctl is-active --quiet "$svc"; then
                sudo systemctl stop "$svc" || true
                sudo systemctl disable "$svc" || true
              fi
            done

            # 2) Remove existing service container (ok if missing)
            docker rm -f "${SERVICE_NAME}" || true

            # 3) Kill any other containers on :80
            OTHER_ON_80=$(docker ps --format '{{.Names}} {{.Ports}}' | awk '/0.0.0.0:80->/ {print $1}')
            [ -n "${OTHER_ON_80:-}" ] && docker rm -f $OTHER_ON_80 || true

            # 4) Wait until :80 is truly free (up to 20s)
            for i in {1..20}; do
              if ! sudo ss -tulpen | grep -qE '(^|[[:space:]])80([[:space:]]|$)'; then
                break
              fi
              sleep 1
            done
            if sudo ss -tulpen | grep -qE '(^|[[:space:]])80([[:space:]]|$)'; then
              echo "ERROR: Port 80 not free"; sudo ss -tulpen | grep ':80 ' || true; exit 125
            fi

            # 5) Build new image and start the service
            docker build -t "${SERVICE_NAME}:latest" .
            docker run -d --restart=always --name "${SERVICE_NAME}" -p 80:80 "${SERVICE_NAME}:latest"

            # 6) Health check
            curl -fsS "http://127.0.0.1/?v=$(date +%s)" | head -n 3 >/dev/null
            echo "Deploy OK: ${SERVICE_NAME} on :80"
          EOF
