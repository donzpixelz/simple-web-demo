name: Deploy static app to EC2 (push-only app/ with no-cache + fallback)

on:
  push:
    branches: ["main"]

concurrency:
  group: deploy-main
  cancel-in-progress: true

jobs:
  deploy:
    runs-on: ubuntu-latest

    env:
      AWS_REGION: us-east-2
      EC2_KEY_NAME: simple-web-demo-key
      WEB_ROOT: /opt/simple-web-demo/app
      CONF_DIR: /opt/simple-web-demo/nginx/conf.d
      CONTAINER: simple-web-demo

    steps:
      - name: Checkout (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Only run when app/**, nginx conf, or workflow changed
      - name: Detect changed paths
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            app:
              - 'app/**'
            conf:
              - 'nginx/default.conf'
            workflow:
              - '.github/workflows/deploy.yml'

      - name: Stop early if nothing relevant changed
        if: steps.changes.outputs.app != 'true' && steps.changes.outputs.conf != 'true' && steps.changes.outputs.workflow != 'true'
        run: |
          echo "No app/ or nginx conf changes; skipping deploy."
          exit 0

      # AWS creds to find instance & edit SG temporarily
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # Pick one instance by ID
      - name: Find EC2 instance/host/SGs
        id: ec2
        shell: bash
        run: |
          set -euo pipefail
          INSTANCE_ID=$(aws ec2 describe-instances \
            --filters "Name=key-name,Values=${EC2_KEY_NAME}" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].InstanceId" --output text | head -n1)
          if [[ -z "$INSTANCE_ID" || "$INSTANCE_ID" == "None" ]]; then
            echo "No running instance found with key-name=${EC2_KEY_NAME} in ${AWS_REGION}"
            exit 1
          fi
          HOST=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" \
            --query "Reservations[].Instances[].PublicDnsName" --output text)
          SG_IDS=$(aws ec2 describe-instances --instance-ids "$INSTANCE_ID" \
            --query "Reservations[].Instances[].SecurityGroups[].GroupId" --output text)
          echo "instance_id=$INSTANCE_ID" >> "$GITHUB_OUTPUT"
          echo "host=$HOST" >> "$GITHUB_OUTPUT"
          echo "sg_ids=$SG_IDS" >> "$GITHUB_OUTPUT"

      # Temporarily allow this GitHub runner to SSH (port 22)
      - name: Authorize runner IP for SSH (temp)
        id: sshopen
        shell: bash
        run: |
          set -euo pipefail
          RUNNER_IP=$(curl -s https://checkip.amazonaws.com | tr -d '\n')
          echo "Runner IP: $RUNNER_IP"
          for SG in ${{ steps.ec2.outputs.sg_ids }}; do
            aws ec2 authorize-security-group-ingress \
              --group-id "$SG" \
              --ip-permissions "IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges=[{CidrIp=${RUNNER_IP}/32,Description=gha-temp}]" \
              || true
          done
          echo "runner_ip=$RUNNER_IP" >> "$GITHUB_OUTPUT"

      # Ensure Docker + dirs; remove any bad 'default.conf' directory
      - name: Prepare server (docker + dirs)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.ec2.outputs.host }}
          username: ec2-user
          key: ${{ secrets.AWS_EC2_SSH_KEY }}
          script: |
            set -euxo pipefail
            WEB_ROOT="${{ env.WEB_ROOT }}"
            CONF_DIR="${{ env.CONF_DIR }}"

            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              sudo systemctl enable --now docker || sudo service docker start || true
            else
              sudo systemctl start docker || sudo service docker start || true
            fi

            sudo mkdir -p "${WEB_ROOT}"
            sudo mkdir -p "${CONF_DIR}"
            if [ -d "${CONF_DIR}/default.conf" ]; then
              sudo rm -rf "${CONF_DIR}/default.conf"
            fi
            sudo chown -R "$USER:$USER" /opt/simple-web-demo

      # Upload config and app content
      - name: Upload nginx/default.conf
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ steps.ec2.outputs.host }}
          username: ec2-user
          key: ${{ secrets.AWS_EC2_SSH_KEY }}
          source: "nginx/default.conf"
          target: "${{ env.CONF_DIR }}/"
          overwrite: true

      - name: Upload app/ to server
        uses: appleboy/scp-action@v0.1.7
        with:
          host: ${{ steps.ec2.outputs.host }}
          username: ec2-user
          key: ${{ secrets.AWS_EC2_SSH_KEY }}
          source: "app/**"
          target: "${{ env.WEB_ROOT }}/"
          strip_components: 1

      # Recreate container; validate nginx; if it fails, fall back to default config
      - name: Recreate container and validate nginx (with fallback)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.ec2.outputs.host }}
          username: ec2-user
          key: ${{ secrets.AWS_EC2_SSH_KEY }}
          script: |
            set -euxo pipefail
            WEB_ROOT="${{ env.WEB_ROOT }}"
            CONF_DIR="${{ env.CONF_DIR }}"
            CONTAINER="${{ env.CONTAINER }}"

            # Ensure Docker daemon is alive
            if ! sudo docker info >/dev/null 2>&1; then
              sudo systemctl start docker || sudo service docker start || true
              if ! sudo docker info >/dev/null 2>&1; then
                nohup sudo dockerd >/tmp/dockerd.log 2>&1 &
                sleep 3
              fi
            fi
            sudo docker info >/dev/null

            # Try with custom conf (no-cache)
            sudo docker rm -f "${CONTAINER}" >/dev/null 2>&1 || true
            sudo docker run -d --name "${CONTAINER}" \
              -p 80:80 -p 8080:80 \
              -v "${WEB_ROOT}":/usr/share/nginx/html:ro \
              -v "${CONF_DIR}":/etc/nginx/conf.d:ro \
              --restart unless-stopped \
              nginx:alpine

            sleep 2
            if ! sudo docker exec "${CONTAINER}" nginx -t; then
              echo "Custom nginx config failed; falling back to default config"
              sudo docker rm -f "${CONTAINER}" || true
              sudo docker run -d --name "${CONTAINER}" \
                -p 80:80 -p 8080:80 \
                -v "${WEB_ROOT}":/usr/share/nginx/html:ro \
                --restart unless-stopped \
                nginx:alpine
              sleep 2
            fi

            echo "--- docker ps ---"
            sudo docker ps --filter "name=${CONTAINER}" --format 'ports={{.Ports}} status={{.Status}}'
            echo "--- served files ---"
            sudo docker exec "${CONTAINER}" sh -lc 'ls -la /usr/share/nginx/html | sed -n "1,200p"'
            echo "--- curl inside container (http://127.0.0.1/) ---"
            sudo docker exec "${CONTAINER}" sh -lc 'wget -qO- http://127.0.0.1/ | head -n 5 || true'
            echo "--- curl from host to localhost:80 and :8080 ---"
            (command -v curl >/dev/null 2>&1 || sudo yum install -y curl >/dev/null 2>&1 || { sudo apt-get update -y && sudo apt-get install -y curl >/dev/null 2>&1; } )
            curl -sv --max-time 5 http://127.0.0.1/ >/dev/null || true
            curl -sv --max-time 5 http://127.0.0.1:8080/ >/dev/null || true

      # Ensure inbound 80 and 8080 are open on the instance SGs
      - name: Ensure SG allows TCP/80 and /8080 from 0.0.0.0/0
        shell: bash
        run: |
          set -euo pipefail
          for SG in ${{ steps.ec2.outputs.sg_ids }}; do
            aws ec2 authorize-security-group-ingress \
              --group-id "$SG" \
              --ip-permissions 'IpProtocol=tcp,FromPort=80,ToPort=80,IpRanges=[{CidrIp=0.0.0.0/0,Description=web-80}]' \
              || true
            aws ec2 authorize-security-group-ingress \
              --group-id "$SG" \
              --ip-permissions 'IpProtocol=tcp,FromPort=8080,ToPort=8080,IpRanges=[{CidrIp=0.0.0.0/0,Description=web-8080}]' \
              || true
          done

      # Remove the temporary SSH ingress
      - name: Revoke runner IP for SSH (cleanup)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          RUNNER_IP="${{ steps.sshopen.outputs.runner_ip }}"
          if [[ -n "$RUNNER_IP" ]]; then
            for SG in ${{ steps.ec2.outputs.sg_ids }}; do
              aws ec2 revoke-security-group-ingress \
                --group-id "$SG" \
                --ip-permissions "IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges=[{CidrIp=${RUNNER_IP}/32,Description=gha-temp}]" \
                || true
            done
          fi

      # External smoke test: try :8080 first, then :80 before failing (with retries)
      - name: Smoke test
        env:
          HOST: ${{ steps.ec2.outputs.host }}
        run: |
          set -euo pipefail
          for URL in "http://${HOST}:8080/" "http://${HOST}/"; do
            echo "Trying ${URL} ..."
            if curl -v --retry 4 --retry-connrefused --retry-delay 3 --max-time 20 -fsS "${URL}?nocache=$(date +%s)" >/dev/null; then
              exit 0
            fi
          done
          echo "Both ports failed"
          exit 7
