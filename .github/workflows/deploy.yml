name: Build and Deploy Demo

on:
  push:
    branches: ["main"]

concurrency:
  group: deploy-main
  cancel-in-progress: true

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest

    env:
      IMAGE_NAME: ${{ secrets.DOCKERHUB_USERNAME }}/simple-web-demo
      AWS_REGION: us-east-2
      EC2_KEY_NAME: simple-web-demo-key
      COMPOSE_DIR: /opt/simple-web-demo
      SERVICE_NAME: web

    steps:
      - name: Checkout code (shallow)
        uses: actions/checkout@v4
        with:
          fetch-depth: 1

      # Detect what changed in this push
      - name: Detect changed paths
        id: changes
        uses: dorny/paths-filter@v3
        with:
          filters: |
            terraform:
              - 'terraform/**'
            app:
              - 'app/**'
            docker:
              - 'Dockerfile'
              - 'docker-compose.yml'
              - '.github/workflows/deploy.yml'

      - name: Log in to Docker Hub
        if: steps.changes.outputs.app == 'true' || steps.changes.outputs.docker == 'true'
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Build and push Docker image (latest + sha)
        if: steps.changes.outputs.app == 'true' || steps.changes.outputs.docker == 'true'
        uses: docker/build-push-action@v6
        with:
          context: .
          push: true
          tags: |
            ${{ env.IMAGE_NAME }}:latest
            ${{ env.IMAGE_NAME }}:${{ github.sha }}
          provenance: false
          no-cache: true

      # Configure AWS creds (needed for EC2 queries and optional Terraform)
      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ---- Terraform runs ONLY if terraform/** changed ----
      - name: Setup Terraform
        if: steps.changes.outputs.terraform == 'true'
        uses: hashicorp/setup-terraform@v3

      - name: Terraform Init
        if: steps.changes.outputs.terraform == 'true'
        working-directory: terraform
        run: terraform init -input=false

      - name: Terraform Apply
        if: steps.changes.outputs.terraform == 'true'
        working-directory: terraform
        run: |
          terraform apply -auto-approve -input=false \
            -var 'ssh_key_name=simple-web-demo-key' \
            -var "dockerhub_username=${{ secrets.DOCKERHUB_USERNAME }}" \
            -var "docker_image=${{ env.IMAGE_NAME }}:latest"

      # ---- Discover instance host + security groups ----
      - name: Find EC2 host and SGs
        id: ec2
        shell: bash
        run: |
          set -euo pipefail
          HOST=$(aws ec2 describe-instances \
            --filters "Name=key-name,Values=${EC2_KEY_NAME}" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].PublicDnsName" --output text)
          if [[ -z "$HOST" || "$HOST" == "None" ]]; then
            echo "No running instance found with key-name=${EC2_KEY_NAME} in region ${AWS_REGION}"
            exit 1
          fi
          SG_IDS=$(aws ec2 describe-instances \
            --filters "Name=key-name,Values=${EC2_KEY_NAME}" "Name=instance-state-name,Values=running" \
            --query "Reservations[].Instances[].SecurityGroups[].GroupId" --output text)
          echo "host=$HOST" >> "$GITHUB_OUTPUT"
          echo "sg_ids=$SG_IDS" >> "$GITHUB_OUTPUT"

      # ---- TEMP open SSH from this runner (and close it after) ----
      - name: Authorize runner IP for SSH (temp)
        id: sshopen
        shell: bash
        run: |
          set -euo pipefail
          RUNNER_IP=$(curl -s https://checkip.amazonaws.com | tr -d '\n')
          echo "Runner IP: $RUNNER_IP"
          for SG in ${{ steps.ec2.outputs.sg_ids }}; do
            aws ec2 authorize-security-group-ingress \
              --group-id "$SG" \
              --ip-permissions "IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges=[{CidrIp=${RUNNER_IP}/32,Description=gha-temp}]" \
              || true
          done
          echo "runner_ip=$RUNNER_IP" >> "$GITHUB_OUTPUT"

      # ---- Deploy over SSH as ec2-user (auto-install git + docker + compose) ----
      - name: Deploy via SSH (pin to commit SHA)
        uses: appleboy/ssh-action@v1.0.0
        with:
          host: ${{ steps.ec2.outputs.host }}
          username: ec2-user
          key: ${{ secrets.AWS_EC2_SSH_KEY }}
          script: |
            set -euo pipefail
            COMPOSE_DIR="${{ env.COMPOSE_DIR }}"
            SERVICE_NAME="${{ env.SERVICE_NAME }}"
            IMAGE_NAME="${{ env.IMAGE_NAME }}"
            IMAGE_TAG="${{ github.sha }}"

            # Install git if missing
            if ! command -v git >/dev/null 2>&1; then
              if command -v yum >/dev/null 2>&1; then
                sudo yum install -y git
              elif command -v dnf >/dev/null 2>&1; then
                sudo dnf install -y git
              elif command -v apt-get >/dev/null 2>&1; then
                sudo apt-get update -y
                sudo apt-get install -y git
              fi
            fi

            # Install Docker if missing (and start it)
            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              sudo systemctl enable --now docker
            fi

            # Ensure Docker Compose (v2 plugin; fallback to v1 binary)
            if ! docker compose version >/dev/null 2>&1; then
              sudo mkdir -p /usr/local/lib/docker/cli-plugins
              if [ ! -x /usr/local/lib/docker/cli-plugins/docker-compose ]; then
                sudo curl -sSL "https://github.com/docker/compose/releases/download/v2.29.2/docker-compose-$(uname -s)-$(uname -m)" \
                  -o /usr/local/lib/docker/cli-plugins/docker-compose
                sudo chmod +x /usr/local/lib/docker/cli-plugins/docker-compose
              fi
            fi
            if ! docker compose version >/dev/null 2>&1 && ! command -v docker-compose >/dev/null 2>&1; then
              sudo curl -sSL "https://github.com/docker/compose/releases/download/1.29.2/docker-compose-$(uname -s)-$(uname -m)" \
                -o /usr/local/bin/docker-compose
              sudo chmod +x /usr/local/bin/docker-compose
            fi
            if docker compose version >/dev/null 2>&1; then
              DC="sudo docker compose"
            else
              DC="sudo docker-compose"
            fi

            sudo mkdir -p "${COMPOSE_DIR}"
            sudo chown -R "$USER:$USER" "${COMPOSE_DIR}"
            cd "${COMPOSE_DIR}"

            # Sync repo (for docker-compose.yml)
            if [ ! -d .git ]; then
              git clone --depth=1 https://github.com/donzpixelz/simple-web-demo .
            else
              git fetch --depth=1 origin main
              git reset --hard origin/main
            fi

            # Write .env so compose uses the SHA tag (unique per deploy)
            cat > .env <<EOF
            IMAGE_NAME=${IMAGE_NAME}
            IMAGE_TAG=${IMAGE_TAG}
            EOF

            # Clean up any existing container (name conflict)
            $DC rm -f -s "${SERVICE_NAME}" || true
            sudo docker rm -f simple-web-demo || true

            # Pull the exact image for this commit and restart only the service
            sudo docker pull "${IMAGE_NAME}:${IMAGE_TAG}"
            $DC up -d --no-deps "${SERVICE_NAME}"

            # Optional cleanup
            sudo docker image prune -f >/dev/null 2>&1 || true

      # ---- Revoke the temporary SSH ingress ----
      - name: Revoke runner IP for SSH (cleanup)
        if: always()
        shell: bash
        run: |
          set -euo pipefail
          RUNNER_IP="${{ steps.sshopen.outputs.runner_ip }}"
          if [[ -n "$RUNNER_IP" ]]; then
            for SG in ${{ steps.ec2.outputs.sg_ids }}; do
              aws ec2 revoke-security-group-ingress \
                --group-id "$SG" \
                --ip-permissions "IpProtocol=tcp,FromPort=22,ToPort=22,IpRanges=[{CidrIp=${RUNNER_IP}/32,Description=gha-temp}]" \
                || true
            done
          fi

      - name: Smoke test
        env:
          HOST: ${{ steps.ec2.outputs.host }}
        run: |
          curl -fsS --max-time 10 "http://${HOST}:8080/" >/dev/null
